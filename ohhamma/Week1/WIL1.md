# [Ch1] 자바 8,9,10,11 : 무슨 일이 일어나고 있는가?

<aside>
✅ 이 장의 내용

- 자바가 거듭 변화하는 이유
- 컴퓨팅 환경의 변화
- 자바에 부여되는 시대적 변화 요구
- 자바 8과 자바 9의 새로운 핵심 기능 소개
</aside>

## 1.1 역사의 흐름은 무엇인가?

> *자바가 멀티코어 병렬성(기존의 자바에서 부족했던 특성)을 더 쉽게 이용할 수 있도록 진화하는 과정과 관련 개념을 설명한다.*
> 
- 멀티코어 CPU 대중화에 따른 자바의 진화 노력
- **자바8**의 요구사항 : 간결한 코드, 멀티코어 프로세서
- **자바8** 핵심 기술
    - `스트림 API` : 병렬 연산 지원
    - `메서드에 코드 전달 기법` : 메서드 참조와 람다
        → 함수형 프로그래밍
    - `인터페이스의 디폴트 메서드`

## 1.2 왜 아직도 자바는 변화하는가?

> *자바8에서 제공하는 코드를 메서드로 전달하는 기법이 어떻게 강력한 새로운 프로그래밍 도구가 될 수 있는지 설명한다.*
> 

### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

- 자바의 출발
    - 많은 유용한 라이브러리를 포함하는 객체지향 언어
    - 동시성 지원 : 스레드와 락 이용
    - JVM 바이트 코드로 컴파일
- 프로그래밍 언어 생태계와 환경 변화 : `멀티코어 프로세서`, 새로운 프로그래머 유입
    - 새로운 언어는 변화하는 환경에 빠르게 적응하면서 점점 대중화
    - 자바8은 현재 시장에서 요구하는 기능을 효과적으로 제공
- 자바8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념
    - 1.2.2 스트림 처리
    - 1.2.3 동작 파라미터화로 메서드에 코드 전달하기
    - 1.2.4 병렬성과 공유 가변 데이터

### 1.2.2 스트림 처리

- 스트림 : 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임
- 유닉스 : 여러 명령 병렬로 실행 (cat, tr, sort, tail)
- 자바8 :  java.util.stream 패키지에 `스트림 API` 추가
    - 어떤 항목을 연속으로 제공하는 어떤 기능
- 하려는 작업을 고수준으로 추상화 → 일련의 스트림으로 만들어 처리
- 입력 부분을 여러 CPU 코어에 쉽게 할당
- 스레드를 사용하지 않으면서 공짜로 병렬성 얻음

### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

- 코드 일부를 API로 전달하는 기능
- `동작 파라미터화` : 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능
- 연산의 동작을 파라미터화

### 1.2.4 병렬성과 공유 가변 데이터

- 병렬성을 공짜로 얻을 수 있다
- synchronized를 사용하면 시스템 성능에 악영향
- 자바8의 스트림을 이용하여 스레드 API보다 쉽게 병렬성 활용
- 명령형 프로그래밍 : 가변 상태로 프로그램 정의, 함수가 정해진 기능만 수행
    → 부작용 일으키지 x
    

### 1.2.5 자바가 진화해야 하는 이유

- 자바의 변화가 가져다주는 편리함 : 에러검출, 가독성↑
- 자바8의 함수형 프로그래밍 도입
    → OOP & FSP 장점 모두 활용
- 언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야함
- 자바8의 새로운 기능에 관심을 가지자 !

## 1.3 자바 함수

> *스트림 API(병렬형 데이터를 표현하고 이들 데이터를 병렬로 처리할 수 있음을 유연하게 보여주는)가 어째서 강력하고 새로운 프로그래밍 도구인지 설명한다.*
> 
- 자바의 함수 : 수학적인 함수, 부작용을 일으키지 않는 함수
- 함수를 값처럼 취급
- 일급값 : 조작할 수 있는 값
  - 변수나 데이터에 담을 수 있음
  - 함수의 파라미터로 전달 가능
  - 함수의 리턴값으로 사용 가능
- 이급값 : 전달할 수 없는 구조체 (메서드, 클래스)
  - 클래스는 자체로 값이 될 수 없음
  - 메서드 참조가 가능해지면서 메서드도 일급값이 됨

### 1.3.1 메서드와 람다를 일급 시민으로

```java
	
new File(".").listFiles(file->file.isHidden());    // 람다 (익명함수)
new File(".").listFiles(File::isHidden);           // 메서드 참조
```

- 자바8에서는 메서드가 일급값
- 메서드 참조를 만들어 전달 가능해짐
- 람다함수도 값으로 취급

### 람다 : 익명 함수

- 자바8 : 람다를 포함하여 함수도 값으로 취급 가능
- 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법 이용
    → 더 간결한 코드 구현
- 함수형 프로그래밍 : 함수를 일급값으로 넘겨주는 프로그램 구현
- 함수형 인터페이스와 동일한 형태를 갖춰야함 : 파라미터, 반환값
  - `(파라미터) -> 반환값` 형태로 작성

### 1.3.2 코드 넘겨주기 : 예제

- 필터 : 특정 항목을 선택해서 반환하는 동작

```java
public interface Predicate<T> {
	booleatn test(T t);
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
	List<Apple> result = new ArrayList<>();
	for (Apple apple: inventory) {
		if (p.test(apple)) {
			result.add(apple);
		}
	}
	return result;
}
```

- 메서드 호출 시

```java
filterApples(inventory, Apple::isGreenApple);
filterApples(inventory, Apple::isHeavyApple);
```

<aside>
💡 predicate : 인수로 값을 받아 true나 false를 반환하는 함수

</aside>

### 1.3.3 메서드 전달에서 람다로

- 자바8 : 익명함수, 람다

```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
filterApples(inventory, (Apple a) -> a.getWeight() < 80 || RED.equals(a.getColor()));
```

- 한번만 사용할 메서드 따로 정의 구현 필요 x
- 람다가 몇 줄 이상으로 길어지면 (복잡한 동작 수행) → 이름을 가진 메서드 정의하는 것이 바람직
    - 코드의 명확성 우선시
- 병렬성을 위해 라이브러리 메서드 filter 대신 새로운 스트림 API 제공 (컬렉션과 유사)
- 컬렉션과 스트림 간 변환 가능한 메서드 제공 : map, reduce

## 1.4 스트림

> *디폴트 메서드라는 새로운 자바8의 기능을 인터페이스, 라이브러리의 간결성 유지 및 재컴파일을 줄이는 데 어떻게 활용할 수 있는지 설명한다.*
> 
- 거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용
- 중첩된 제어 흐름 문장 해결

```java
import static java.util.stream.Collectors.groupingBy;
Map<Currency, List<Transaction>> transactionsByCurrencies = 
	transactions.stream()
		.filter((Transaction t) -> t.getPrice > 1000);
		.collect(groupingBy(Transaction::getCurrency));
```

- 컬렉션에서는 반복 과정 직접 처리 (외부 반복)
- 스트림 API에서는 라이브러리 내부에서 모든 데이터 처리됨 (내부 반복)

### 1.4.1 멀티스레딩은 어렵다

- 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있음
    - 동시에 공유된 데이터에 접근 및 갱신
- 멀티스레딩 모델은 순차적인 모델보다 다루기가 어렵다
- 자바8 : 스트림 API로 두 가지 문제 해결
    1. 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제
    2. 멀티코어 활용 어려움

<aside>
💡 데이터 필터링, 추출, 그룹화 등의 기능 → 쉽게 병렬화 가능

1. 포킹 단계 : 서로 다른 CPU가 리스트의 서로 다른 부분을 처리하도록 요청
2. 각각의 CPU가 맡은 리스트 처리
3. 하나의 CPU가 결과 정리
</aside>

- **컬렉션** : 어떻게 데이터를 저장하고 접근할지
- **스트림** : 데이터에 어떤 계산을 할 것인지 묘사
    - 스트림 내 요소를 쉽게 병렬로 처리할 수 있는 환경 제공

```java
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples = 
	inventory.**parallelStream()**.filter((Apple a) -> a.getWeight() > 150)
														.collect(toList());
```

- 함수형 프로그래밍 : 프로그램이 실행되는 동안 컴포넌트 간에 상호작용이 일어나지 않는다
    - 가변 공유 객체를 통해 공짜로 병렬성 누릴수있음
- 기존 인터페이스의 변경 : 불가능에 가까웠음
    → 자바8 : 디폴트 메서드로 문제 해결
    

## 1.5 디폴트 메서드와 자바 모듈

> *JVM을 구성하는 자바 및 기타 언어에서 함수형 프로그래밍이라는 존재가 어떤 영향을 미치는지 제시한다.*
> 
- 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향
- 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야했음
- 자바9 : 모듈 정의 문법 제공
    → JAR 컴포넌트에 구조 적용, 문서화 및 모듈 확인 작업 용이
- 자바8 : 디폴트 메서드 지원, 인터페이스 쉽게 바꿀수있음

<aside>
❓ 어떻게 기존의 구현을 고치지 않고도 이미 공개된 인터페이스를 변경할 수 있을까?

</aside>

- 자바8 : 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능 제공
    → 디폴트 메서드 (default) : 인터페이스에서 구현부(몸체)를 가질 수 있는 메서드
    

```java
default void sort(Comaparator<? super E> c) {
	Collections.sort(this, c);
}
```

- 9장 → 다이아몬드 상속 문제를 피할 수 있는 방법 설명

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

<aside>
💡 자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어

- 메서드와 람다를 일급값으로 사용
- 가변 공유 상태가 없는 병렬 실행 이용
</aside>

- 자바8 : Optional<T> 클래스 제공
    → NullPointer 예외 피할수있음
- 구조적 패턴 매칭 기법 : switch를 확장한것
    - 데이터 형식 분류와 분석 한번에 수행 가능
    - 방문자 패턴 → 에러 검출 가능
# WIL1 - 1장

해당 주차는 자바8 이후의 특정 개념을 다루는게 아닌 자바8이 가져온 변화와 책에서 전반적으로 설명할 내용에 대해 정리한다.

이번 WIL에선 그 흐름과 기본적으로 알아야할 것 같은 용어에 대해 정리해보겠다.

### **자바 8 이 가져온 변화. 왜 자바8에 주목하는가?**

자바를 사용해 사람들과 이야기, 강의를 들어본 사람이라면 자바8 이후에 나온,, 자바8이 어쩌구.. 하는 이야기를 많이 들었을 것이다. 자바8이 왜 그렇게 많이 언급되는지 궁금했다.

가장 큰 포인트는 **병렬 관리**였다.  책에서는 자바8에서 병렬 연산을 지원하는 **스트림 API**와 이를 위해 등장한 2가지 기능인 **메서드에 파라미터로 코드를 전달**하는 기법, **인터페이스의 디폴트메서드**에 전 주목한다.

이를 알기 위해선 자바 8 이전 즉, 자바7 이전 버전과 자바8이 나오던 당시의 상황을 중점으로 알아야한다.

### **자바 8 이전의 병렬처리**

병렬처리는 자바7 이전인 자바1부터 가능했다. 하드웨어의 발전에도 멀티코어 CPU를 사용하기 위해선 스레드를 사용했다. 하지만, 스레드는 관리가 어렵고 특히 가변 공유변수를 관리하기 어렵다, 멀티스레딩이 어렵다는 단점이 있었다.

자바 7에서 포크/조인 프레임워크가 등장했지만 이 역시도 활용이 쉽지 않았다.

또한 당시 하드웨어의 변화와 개발자의 기대에 따른 **필요성**에 관한 3가지 개념이 존재했는데, 자바8에선 이 필요성을 충족시켜줬다고 한다.

- 스트림 처리
- 동작 파라미터화로 메서드에 코드 전달하기
- 병렬성과 공유 가변 데이터: 안전한 병렬성

자바8은 강력한 이점을 발휘했다고 한다. 지금부터 그 기술들은 간략히 살펴보자.

---

### **자바함수**

프로그래밍 언어의 핵심은 값을 변화하는 것, 그리고 **값을 전달하는 것**을 의미한다. 책에서는 전달되는 **값**이 일급시민이라고 표현하고 전달되지 않는 **구조체, 메서드, 클래스**를 이급 시민이라 표현한다.

이들을 전달할 수 있다면? 일급 시민이 되는 것이다.

자바 8은 메서드 전달을 아래의 두 가지 방법으로 이를 가능하게 했다.

### **1. 메서드 참조**

자바 8에서는 아래 코드와 같이 '해당 메서드를 값으로 사용하라'는 의미로 메서드를 파라미터로 전달할 수 있다.

`List<Apple> greenApples = filterApples(inventory, FilteringApples::isGreenApple);`

이렇게 메서드를 전달할 수 있는 값이 된다.

Q. 메서드 vs 함수?

### **2. 람다 함수**

자바 8에서는 또한 익명함수인 람다함수로 메서드를 값으로 전달할 수 있다.

람다를 사용하게 되면 코드가 간결해진다는 장점이 있다.

`List<Apple> heavyApples2 = filterApples(inventory, (Apple a) -> a.getWeight() > 150);`

두 방법 모두 사용이 가능하지만 상황에 따라 적절히 선택하면 된다.

메서드 정의하는 것도 귀찮다면 람다를 사용!

람다 코드가 길어진다면? 가독성을 위해 (하는일을 명확히 설명하기 위해) 람다보단 메서드 정의! 하는 방법을 택하자.

---

### **스트림**

대부분의 코드는 컬렉션을 사용한다. 컬렉션에 있는 원소에 어떠한 작업을 하기 위해선 대부분 for-each루프를 사용해 값을 하나씩 꺼내 각 요소를 반복하며 작업을 처리한다. 이러한 for-each 루프를 **외부 반복**이라고 한다. (값을 꺼내서 사용하니까?)

하지만, 스트림을 사용하면 내부 반복을 하게 된다.

```java
Map<Currency,List<Transaction>> transactionsByCurrencies =
					transactions.stream()
                    .filter((Transaction t)-> t.getPrice() > 1000)//고가의 트랜잭션 필터링
                    .collect(groupingBy(Transaction::getCurrency));// cur로 그룹화
```

이렇게 처리하면 다음과 같은 장점이 있다고 생각한다.

1. 값을 하나하나 외부에 노출 하는 코드를 짤 필요가 없다고 생각

2. 오히려 코드가 하는 작업이 한눈에 읽혀 가독성이 오른다. (코드를 이해하기 편하다.)

컬렉션을 처리하며 생긴 문제인 반복적인 패턴 작업을 해결할 수 있고, 코드의 모호함을 해소할 수 있게 된 것이다.

또한 앞서 말했듯, 자바8 이전에 멀티스레딩을 통한 병렬처리는 **공유 변수의 접근 순서에 따른 문제**가 있었다.

**Q. 이 문제는 어떻게 해결하죠..?**

필터링 - 추출 - 그룹화

- 멀티 코어 활용 어려움.

**상호작용?**

정리하면 컬렉션과 스트림의 특징적인 차이는 다음과 같다.

컬렉션: 데이터 저장, 접근

스트림: 어떤 계산을 할지에 초점

---

### **디폴트 메서드**

특정 인터페이스를 구현하는 구현체를 생각해보자. 책에서는 Collection -> List -> sort를 예로 들었다.

특정 구현체(List)에 새로운 메서드를 추가하고 싶다면 어떻게 해야할까? 인터페이스에 해당 함수를 추가하고 구현체에 구현을 하면된다. 하지만, 이 경우 인터페이스를 구현하는 다른 구현체들에도 메서드를 추가해야한다는 단점이 존재했다.

즉, 구현체를 다 수정해야했기때문에 인터페이스를 바꾸기 어려웠다.

이를 해결하기 위해 자바8에서는 구현하지 않아도 되는 메서드를 인터페이스에 추가했다. 그 메서드를 디폴트 메서드라고 한다.

List에 sort함수를 사용하고 싶으면 collection에 sort를 디폴트함수로 추가하면 되는 것이다!

---

얘네들은 왜 얘기한건지.. 장하고 매핑 잘안되는듯

**1.2 코드로 메서드 전달의 강점**

**1.3 스트림API가 왜 강력한 프로그래밍 도구인지**

메서드를 전달할 수ㅇ 있는 값으로 (메서드 참조, 람다)

**1.4 디폴트 메서드의 메리트**

**1.5 JVM쓰는 다른 언어에서 함수형 프로그래밍의 영향력**
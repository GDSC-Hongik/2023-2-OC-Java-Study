# Effective Java Item 42

## **익명 클래스보다는 람다를 사용하라**

과거 자바는 추상 메서드 하나만 담은 인터페이스(현재의 함수형 인터페이스)를 사용해 함수의 타입을 표현했다. 이런 인터페이스의 인스턴스를 함수객체라 하였고 익명 클래스를 통해 함수 객체를 만들었다. 이는 과거 객체지향 디자인 패턴에는 충분한 방법이었다.

그러나, 함수형 프로그래밍이란 개념이 등장하며 익명클래스 방식은 코드가 너무 길기에 적합하지 않았다.

**람다의 등장**

자바 8 부턴 함수형 인터페이스의 인스턴스를 익명 클래스가 아닌 람다식을 사용해 만들 수 있게 되었다. 람다를 통해 훨씬 더 간결하게 코드를 만들고 어떤 동작을 하는지도 명확히 알 수 있었다.

```java
Collections.sort(words, (s1,s2)->Integer.compare(s1.length(),s2.length());
```

또한, 길이만 짧아진 것이 아닌 타입도 명시하지 않았는데 컴파일러가 context를 적절히 살펴 타입을 추론할 수 있게 되었다. 컴파일러가 타입을 추론하지 못할때, 명시적으로 타입을 명시해야할 때는 타입을 개발자가 직접 명시해야하지만 그 외에는 생략이 가능해 코드가 훨씬 간결해졌다.

**생성 메서드를 사용한 코드의 간결화**

람다 자리엔 아래와 같이 메서드를 직접 참조해 코드를 간단하게 만들 수 있다.

```java
words.sort(comparingInt(String::length));
```

**람다, 장점만 있을까?**

그러나, 람다는 메서드와 달리 이름도 없고 문서화도 불가능하다. 따라서, 람다 코드만으로 동작이 명시적으로 설명되지 않거나 줄이 길어지면 람다를 쓰면 안된다. 필자는 1~3줄안에 코드를 마무리하는 것을 권장한다.

**익명 클래스 이대로 사라지나?**

람다는 함수형 인터페이스에서만 쓰인다. 추상 클래스의 인스턴스를 만들때는 람다를 사용할 수 없다. 또한, 함수형 인터페이스가 아닌 추상 메서드가 여러개인 인터페이스의 인스턴스를 만들때에도 익명 클래스가 사용된다. 또한 람다는 자신을 참조할 수 없어 람다 내부에서 this를 써도 해당 람다가 아닌 람다 외부의 인스턴스를 가리키지만 익명 클래스의 this는 자신을 가르쳐 자기 자신을 참조해야하는 경우에도 익명 클래스를 쓸 수 있다.

또한, 람다와 익명 클래스 모두 직렬화하는 일은 삼가하자!
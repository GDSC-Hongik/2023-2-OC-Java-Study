# Effective Java Item 42

## **익명 클래스보다는 람다를 사용하라**

과거 자바는 추상 메서드 하나만 담은 인터페이스(현재의 함수형 인터페이스)를 사용해 함수의 타입을 표현했다. 이런 인터페이스의 인스턴스를 함수객체라 하였고 익명 클래스를 통해 함수 객체를 만들었다. 이는 과거 객체지향 디자인 패턴에는 충분한 방법이었다.

그러나, 함수형 프로그래밍이란 개념이 등장하며 익명클래스 방식은 코드가 너무 길기에 적합하지 않았다.

**람다의 등장**

자바 8 부턴 함수형 인터페이스의 인스턴스를 익명 클래스가 아닌 람다식을 사용해 만들 수 있게 되었다. 람다를 통해 훨씬 더 간결하게 코드를 만들고 어떤 동작을 하는지도 명확히 알 수 있었다.

```java
Collections.sort(words, (s1,s2)->Integer.compare(s1.length(),s2.length());
```

또한, 길이만 짧아진 것이 아닌 타입도 명시하지 않았는데 컴파일러가 context를 적절히 살펴 타입을 추론할 수 있게 되었다. 컴파일러가 타입을 추론하지 못할때, 명시적으로 타입을 명시해야할 때는 타입을 개발자가 직접 명시해야하지만 그 외에는 생략이 가능해 코드가 훨씬 간결해졌다.

**생성 메서드를 사용한 코드의 간결화**

람다 자리엔 아래와 같이 메서드를 직접 참조해 코드를 간단하게 만들 수 있다.

```java
words.sort(comparingInt(String::length));
```

**람다, 장점만 있을까?**

그러나, 람다는 메서드와 달리 이름도 없고 문서화도 불가능하다. 따라서, 람다 코드만으로 동작이 명시적으로 설명되지 않거나 줄이 길어지면 람다를 쓰면 안된다. 필자는 1~3줄안에 코드를 마무리하는 것을 권장한다.

**익명 클래스 이대로 사라지나?**

람다는 함수형 인터페이스에서만 쓰인다. 추상 클래스의 인스턴스를 만들때는 람다를 사용할 수 없다. 또한, 함수형 인터페이스가 아닌 추상 메서드가 여러개인 인터페이스의 인스턴스를 만들때에도 익명 클래스가 사용된다. 또한 람다는 자신을 참조할 수 없어 람다 내부에서 this를 써도 해당 람다가 아닌 람다 외부의 인스턴스를 가리키지만 익명 클래스의 this는 자신을 가르쳐 자기 자신을 참조해야하는 경우에도 익명 클래스를 쓸 수 있다.

또한, 람다와 익명 클래스 모두 직렬화하는 일은 삼가하자!


### **직렬화란?**
앞에서 람다를 직렬화하는 일을 삼가하자 했는데 직렬화란 무엇일까?
직렬화란, JVM의 Heap, Stack등 휘발성 메모리에 있는 객체를 Stream of Bytes로 변환해 다른 파일이나, DB와 같은 외부 저장소에 저장이 가능하게 하는 과정을 의미한다.

직렬화는 자바의 고유 기술로, 자바 시스템 개발에선 최적화 되어 있어 다른 여러 타입과 데이터를 매칭시키는 별도의 작업이 없이 바로 외부에 내보낼 수 있다는 장점이 있다.

**그럼 람다 직렬화는 어떻게 하나요?**

람다와 익명클래스는 인스턴스 메서드처럼 정적인 형태를 갖지 않아 바로 직렬화가 불가능하다. 직렬화를 해야하는 경우엔 `private static nested class`를 사용해야한다. 인터페이스를 클래스 내부에 생성하고 인터페이스를 구현하는 클래스를 생성해 다른 외부 클래스에선 직접적인 접근을 막는 객체를 정적 클래스를 생성하고 람다를 직렬화할 수 있다.

아래 코드 같이 예시를 들 수 있다.
```Java
public class LambdaSerializable {
    public static void main(String[] args) {
        LambdaFunction<Integer> function = x -> x>150;
        System.out.println(function.test(200));
        System.out.println(function.test(100));
    }


    private static interface LambdaFunction<T> extends Serializable {
        boolean test(T o);
    }

}
```
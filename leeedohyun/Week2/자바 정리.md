# 자바 컬렉션 프레임워크
- 대량의 데이터를 효율적으로 처리할 수 있는 기능을 제공해주는 클래스의 집합을 의미
- 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현
- List, Set, Map + Queue
- List, Set, Queue 인터페이는 Collection 인터페이스를 상속받지만 Map 인터페이스는 구조적 특성으로 독립적으로 정의되어 있다.

## List 인터페이스
- 순서 개념이 있는 데이터의 집합
- 인덱스를 관리
- 요소의 순서가 유지되며 동일한 요소의 중복 저장을 허용
- 클래스
    - ArrayList
    - LinkedList
    - Vector
    - Stack

### ArayList<E>
- 단방향 포인터 구조로 각 데이터의 인덱스를 가지고 있어 조회 성능이 뛰어나다.
- 내부적으로 배열을 이용하여 요소를 저장
- 배열의 크기를 고정할 수 없는 인스턴스로 크기 조정을 위해 새로운 배열을 생성하고 기존 요소들을 옮기는 작업이 수행된다.

#### 주요 메서드
|메소드|Return Type| 설명
|----|-----|----
|add(E e)| boolean| 데이터를 배열 끝에 추가
|add(int idx, E e)| void| 지정된 index에 위치에 데이터 저장
|size()| int| 데이터의 개수 리턴
|get(int index)| E| 해당 index의 데이터 리턴
|indexOf(Object o)| int| 전달된 객체와 동일한 데이터의 위치 리턴
|toArray()| Object[]| 객체의 값들을 해당 타입의 배열로 변환하여 리턴
|clear()| void| 모든 데이터 삭제
|remove(int index)| E| 해당 index의 데이터 삭제 후 그 데이터 리턴
|set(int index, E e)| E| 해당 index의 데이터 변경하고, 원래 데이터 리턴
|

### LinkedList<E>
- 각 데이터가 노드와 포인터로 구성이 되어 연결되어 있는 방식의 구조
- 각 데이터가 포인터로 연결되어 있는 구조여서 중간에 데이터를 삽입하거나 삭제하기 용이하다.

#### 주요 메서드
|메소드|Return Type| 설명
|----|-----|----
|add(int idx, Object o)| void| 지정된 index에 객체를 추가
|offer(E o)| boolean| 해당 요소를 끝에 추가
|peek()| E| 첫 번째 요소 리턴
|poll()| E| 첫 번째 요소 리턴 후 삭제
|subList(int f, int t)| List| f ~ t 사이의 객체를 List로 변환하여 리턴
|

### Vector<E>
- 기본적으로 ArrayList와 동일한 자료 구조를 가지고 있음
- ArrayList와 동일한 기능으로 동작
- 차이점: Thread-safe하다는 것 => 어플리케이션을 구성할 때 멀티 스레딩 기능을 추가하게 되는데 ArrayList의 경우 데이터가 보존되지 않는다. Vector를 사용하면 계속해서 스레드가 접근할 때마다 동기화를 해주기 때문에 조금 더 정확한 데이터를 얻을 수 있다.
- 그러나 Thread가 한 개일 경우에도 동기화하기 때문에 ArrayList보다 성능이 떨어짐

### Stack<E>
- Vector 클래스를 상속받아 전형적인 Stack 메모리 구조를 제공
- 다루는 데이터에 대해 후입선출(LIFO)의 구조를 가지고 있음
- LIFO: Last In First Out의 줄임말로 나중에 저장된 데이터가 가장 먼저 나오는 구조를 의미

#### 주요 메서드
|메소드|Return Type| 설명
|----|-----|----
|peek()| E| 스택의 제일 마지막에 저장된 요소 리턴
|pop()| E| 스택의 제일 마지막에 저장된 요소 리턴 후 삭제
|push(E e)| E| 스택의 제일 마지막에 요소를 저장
|

# Queue 인터페이스
## Queue<E>
- 데이터를 일시적으로 쌓아 두기 위한 자료 구조
- Stack과 다르게 FIFO(First In First Out) 형태를 가짐
- Queue를 생성할 때 LinkedList를 활용하여 생성

### 주요 메서드
|메소드|Return Type| 설명
|----|-----|----
|add(E e)| boolean| 큐의 마지막에 요소를 삽입(실패 시 예외 발생)
|offer(E o)| boolean| 큐의 마지막에 요소를 삽입(실패 시 false 리턴)
|element()| E| 큐의 제일 앞의 요소를 리턴(실패 시 예외 발생)
|peek()| E| 큐의 제일 앞의 요소를 리턴(큐가 비었으면 null 리턴)
|poll()| E| 큐의 제일 앞의 요소를 리턴 후 삭제(큐가 비었으면 null 리턴)
|remove()| E| 큐의 제일 앞의 요소를 리턴 후 삭제(큐가 비었으면 예외 발생)
|

## PriorityQueue<E>
- 우선순위 큐는 데이터의 우선순위를 결정하여 우선순위가 가장 높은 요소가 먼저 나가는 자료 구조
- 우선순위 큐는 힙을 이용하여 구현되어, 우선순위를 기준으로 최대힙, 최소힙으로 구성됨
- 힙으로 구성되어 있다는 것은 이진 트리 구조로 이루어져 있다는 것을 의미
- 시간 복잡도는 O(nlogn)

### 동작원리

## Set 인터페이스
- 순서 개념이 없는 데이터의 집합
- 데이터의 중복이 허용되지 않음
- 데이터를 탐색하기 위해서 iterator를 생성하여 데이터를 가져와야 함
- HashSet: 데이터를 중복 저장할 수 없고 순서를 보장하지 않음
- TreeSet: 오름차순으로 데이터를 정렬하여 저장
- LinkedHashSet: 입력된 순서대로 데이터를 관리

### 메서드
|메소드|Return Type| 설명
|----|-----|----
|add()| boolean| set에 전달된 요소 추가
|clear()| void| set의 모든 요소 제거
|contains()| boolean| 해당 집합에 특정 요소가 포함되어 있는지 체크
|equals()| boolean| set의 요소 집합과 전달된 객체가 같은지 체크
|isEmpty()| boolean| set이 비어 있는지 체크
|iterator()| Iterator<E>| set의 반복자를 리턴
|remove()| boolean| set에서 전달된 객체 제거
|size()| int| set에 포함된 요소의 개수 리턴
| toArray()| Object[]| set의 모든 요소를 배열로 반환
|

### HashSet<E>
- Set 인터페이스의 구현체
- 동일한 객체를 중복해서 저장할 수 없으며, 순서 또한 보장되지 않음
- 순서 보장을 위해서는 LinkedHashSet을 사용해야 함
- 값을 추가 및 삭제하는 과정에서 Set 내부에 해당 값이 있는지 확인하는 단계를 거치기 때문에 List에 비해서 연산 속도가 느리다.

### TreeSet<E>
- Set 인터페이스의 구현체
- 동일한 객체를 중복해서 저장할 수 없으며, 순서 또한 보장되지 않음
- HashSet과는 다르게 이진 탐색 트리 구조로 이루어져 있어 값의 추가 및 제거에는 시간이 오래 걸리는 반면 정렬 및 검색에 높은 성능을 가진다.

# effectively final
`effectively final`이란 자바에서 `final` 키워드가 선언되지 않은 변수지만 값이 재할당되지 않아 `final` 과 유사하게 동작하는 것을 말한다. 이 개념은 자바 8에서 도입되었는데, 익명 클래스(Anonymous Classes) 또는 람다식(Lambda Expressions)이 사용된 코드에서 쉽게 찾아볼 수 있다. 다음 조건을 만족하면 `effectively final`이라고 할 수 있다.

- final로 선언되지 않았다.
- 초기화를 하고 다시 할당하지 않았다.
- 전위 또는 후위에 증감 또는 감소 연산자가 사용되지 않았다.

객체의 경우에는 객체가 가리키는 참조를 변경하지 않으면 된다.

## Lambda Capturing
람다는 외부에 정의된 변수를 사용할 때 내부에서 사용할 수 있도록 복사본을 생성하는데, 이를 람다 캡쳐링(Lambda Capturing)이라고 부른다. 복사본을 만드는 이유는 무엇일까? 지역 변수는 스택 영역에 할당된다. 스택은 스레드마다 자신의 고유한 영역을 갖는다는 특성이 있기 때문에 스레드끼리 공유할 수 없을 뿐만 아니라 스레드가 종료되면 스택도 사라진다. 그렇게 되면 외부 지역 변수를 그대로 참조하지 못한다. 이것이 람다 캡쳐링을 하는 이유이다.

## 람다에서 외부 지역 변수의 값을 변경할 수 없는 이유는 무엇일까?
람다식은 별도의 스레드에서 수행되기 때문에 외부 지역 변수를 제어하는 스레드와는 서로 다를 수 있다. 그렇기 때문에 람다식은 외부 지역 변수를 캡쳐링하고 람다식이 수행되는 스레드에서 캡쳐링된 외부 지역 변수가 변경되었는지 확인할 방법이 없다. 그래서 람다는 외부 지역 변수의 값을 참조하는 경우에 값이 변경되지 않아야 한다.

## 인스턴스 변수와 클래스 변수도 지역 변수와 동일할까?
인스턴스 변수는 힙 영역에 할당되고, 클래스 변수는 메서드 영역에 할당된다. 그렇기 때문에 할당된 메모리 영역이 지역 변수가 할당되는 스택 영역과 다르게 바로 회수되지 않아 복사하는 과정이 불필요하다.

# Java HashMap은 어떻게 동작하는가?
HashMap이 어떻게 동작하는지 이해하려면 먼저, HashMap에 대해서 알아야 한다. HashMap은 Map 인터페이스를 구현한 대표적인 Map 컬렉션이다. Map을 상속받고 있기 때문에 Map의 성질을 그대로 가지고 있다. Map에 대해서 간단하게 살펴보자. Map은 key와 value로 구성된 Entry 객체를 저장하는 자료 구조이다. value는 중복될 수 있지만 key는 중복될 수 없다. HashMap은 이름에서도 드러나듯이 Hashing을 사용하기 때문에 많은 양의 데이터를 검색하는 데 성능이 뛰어나다.

## 해시 분포와 해시 충돌
- 해시 분포: HashMap에서 사용되는 해시 함수로 인해 키들이 어떻게 해시 값들로 분포되는지를 나타낸다.
- 해시 충돌: 다른 내용의 데이터가 같은 키 값을 가지는 경우

### Open Addressing
`Open Addressing`은 데이터를 삽입하려는 해시 버킷이 이미 사용 중인 경우 다른 해시 버킷에 해당 데이터를 삽입하는 방식이다.
- Worst Case O(M)
- 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비하여 캐시 효율이 높다.(데이터 개수가 적을 때 성능이 좋다.)

### Seperate Chaining
`Separate Chaining`에서 각 배열의 인자는 인덱스가 같은 해시 버킷을 연결한 링크드 리스트의 첫 부분(head)이다.
- Worst Case O(M)
- 배열의 크기가 커질수록(M 값이 커질수록) L1, L2 캐시 적중률(hit ratio)이 낮아지기 때문에 캐시 효율이라는 Open Addressing의 장점은 사라진다.
- Java에서 사용하는 방식

## Java 8 HashMap에서의 Separate Chaining
데이터의 개수가 많아지면 링크드 리스트 대신 트리를 사용하기 때문에 Java 8에서 더 효율적이다.

```java
static final int TREEIFY_THRESHOLD = 8;

static final int UNTREEIFY_THRESHOLD = 6;  
```

- 링크드 리스트를 사용할 것인가 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 키-값 쌍의 개수이다. 
- 하나의 해시 버킷에 8개의 키-값 쌍이 모이면 링크드 리스트를 트리로 변경 
- 만약 해당 버킷에 있는 데이터를 삭제하여 개수가 6개에 이르면 다시 링크드 리스트로 변경

이 차이를 1이 아니라 2로 둔 것은 불필요하게 트리와 링크드 리스트로 변경될 수 있기 때문에 이를 방지하기 위함이다. 

앞에서 HashMap을 설명할 때 HashMap에서는 Entry 클래스를 사용한다고 했다. 하지만 Java 8에서는 Entry 클래스 대신 Node 클래스를 사용한다. 다른 점이 있다면 링크드 리스트 대신 트리를 사용할 수 있도록 하위 클래스에 TreeNode가 있다는 것이다. 이때 사용하는 트리는 Red-Black Tree이다. 여기서 Red-Black Tree란, 자가 균형 이진 탐색 트리로 다음과 같은 조건을 만족시켜야 한다.

-  모든 노드는 빨간색 혹은 검은색이다.
- 루트 노드는 검은색이다.
- 모든 리프 노드(NIL)들은 검은색이다. (NIL : null leaf, 자료를 갖지 않고 트리의 끝을 나타내는 노드)
- 빨간색 노드의 자식은 검은색이다.
   == No Double Red(빨간색 노드가 연속으로 나올 수 없다)
- 모든 리프 노드에서 Black Depth는 같다.
   == 리프노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수가 같다.

Red-Black Tree는 Java Collections Framework의 TreeMap과 구현이 거의 같다. 트리 순회 시 사용하는 대소 판단 기준은 해시 함수 값이다. 해시 값을 대소 판단 기준으로 사용하면 Total Ordering에 문제가 생기는데, Java 8 HashMap에서는 이를 tieBreakOrder() 메서드로 해결한다.

```java
// 블로그 설명 그대로 가져온 tieBreakOrder()
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    static int tieBreakOrder(Object a, Object b) {
         // TreeNode에서 어떤 두 키의comparator 값이 같다면 서로 동등하게 취급된다.
         // 그런데 어떤 두 개의 키의 hash 값이 서로 같아도 이 둘은 서로 동등하지 않을 수 있다. 
         // 따라서 어떤 두 개의 키에 대한 해시 함수 값이 같을 경우, 
         // 임의로 대소 관계를 지정할 필요가 있는 경우가 있다. 
    }
}
```

## 해시 버킷 동적 확장
해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능상 손실이 발생한다. 그래서 HashMap은 키-값 쌍 데이터 개수가 일정 개수 이상이 되면, 해시 버킷의 개수를 두 배로 늘린다. 이렇게 해시 버킷 개수를 늘리면 N/M 값도 작아져, 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다.

그런데, 버킷의 개수를 확장하면서 문제가 발생한다. 버킷의 개수가 두 배씩 증가할 때마다 모든 키-값 데이터를 읽어 새로운 Separate Chaining을 구성해야 한다. 이를 방지하기 위해서 HashMap에 저장될 데이터의 개수가 예측이 가능하다면 초기 해시 버킷 개수를 지정해야 한다.

그런데 이렇게 해시 버킷 크기를 두 배로 확장하는 것에는 결정적인 문제가 있다. 해시 버킷의 개수 M이 2^a 형태가 되기 때문에, index = X.hashCode() % M을 계산할 때 X.hashCode()의 하위 a개의 비트만 사용하게 된다는 것이다. 즉 해시 함수가 32비트 영역을 고르게 사용하도록 만들었다 하더라도 해시 값을 2의 승수로 나누면 해시 충돌이 쉽게 발생할 수 있다. 

## 해시 보조 함수
위의 문제 때문에 해시 보조 함수가 필요하다. 보조 해시 함수의 목적은 '키'의 해시 값을 변형하여, 해시 충돌 가능성을 줄이는 것이다. 이 보조 해시 함수는 JDK 1.4에 처음 등장해서 Java 5 ~ Java 7은 같은 방식의 보조 해시 함수를 사용하고, Java 8부터는 다시 새로운 방식의 보조 해시 함수를 사용하고 있다.

```java
static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); }
```

위의 코드에서 확인할 수 있듯이 Java 8 HashMap 보조 해시 함수는 상위 16비트 값을 XOR 연산하는 매우 단순한 형태의 보조 해시 함수를 사용한다. 이 이유에는 두 가지가 있다.

- Java 8에서는 해시 충돌이 많이 발생하면 링크드 리스트 대신 트리를 사용하므로 해시 충돌 시 발생할 수 있는 성능 문제가 완화되었기 때문이다.
- 최근의 해시 함수는 균등 분포가 잘 되게 만들어지는 경향이 많아, Java 7까지 사용했던 보조 해시 함수의 효과가 크지 않기 때문이다. 

## String 객체에 대한 해시 함수
String 객체에 대한 해시 함수 수행 시간은 문자열 길이에 비례한다.

```java
public int hashCode() {  
    int hash = 0;
    int skip = Math.max(1, length() / 8);
    for (int i = 0; i < length(): i+= skip) 
        hash = s[i] + (37 * hash);
    return hash;
}
```

위의 코드는 JDK1.1에서의 String 클래스 해시 함수이다. JDK1.1에서 String 클래스 해시 함수는 문자열의 길이가 16을 넘으면 최소 하나의 문자를 건너가며 해시 함수를 계산한다는 것을 코드를 보면 알 수 있다. 그러나 이런 방식은 심각한 문제를 야기했다. 웹상의 URL은 길이가 수십 글자에 이르면서 앞 부분은 동일하게 구성되는 경우가 많다. 이 경우 서로 다른 URL의 해시 값이 같아지는 빈도가 매우 높아질 수 있다는 문제가 있다. 따라서 이런 방식은 곧 폐기되었고, 다음에서 보는 방식을 현재의 Java 8까지도 계속 사용하고 있다.

```java
public int hashCode() {  
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

스트링 함수에서 31을 사용하는 이유는 뭘까? 단순하게, 31이 소수이면서 어떤 수에 31을 곱하는 것은 빠르게 계산할 수 있기 때문이다.
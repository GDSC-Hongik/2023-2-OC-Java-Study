# Java의 정의와 동작 방식
## Java란?
객체 지향 언어이지만 pure한 객체 지향 언어가 아니다. 그렇다면 순수 객체 지향 언어의 특징은 뭘까?
- 추상화
- 다형성
- 캡슐화
- 상속
- 모든 사전 정의 데이터 타입과 사용자 정의 타입은 객체여야 한다.
- 객체에 대한 모든 작업은 객체 스스로 정해야 한다.

위의 6가지 특징을 만족해야 순수 객체 지향 언어라고 할 수 있다. 자바가 지키지 못한 순수 객체 지향 언어의 특징에 대해서 알아보자.
- 원시 타입(Primitive Type)
- 정적 메서드(Static Method)
- 래퍼 클래스(Wrapper Class) 또한 Auto Boxing/Unboxing을 통해 원시 타입 변수 사용

그렇기 때문에 자바는 객체 지향 언어이지만 일부 절차적인 요소가 있다.

## Java 아키텍쳐
![image](https://github.com/GDSC-Hongik/2023-2-OC-Java-Study/assets/116694226/8768b029-d968-4a92-966b-af119f76b881)

### JDK(Java Development Kit) 
JDK는 자바 프로그램 실행 및 개발 환경을 제공한다. JDK 11 이후에는 JRE를 포함하여 OpenJDK를 제공하고 일관된 환경 제공을 위해 단순화 되었다.

### JVM(Java Virtual Machine)
JVM은 자바 가상 머신이라고 불리며, 논리적인 개념으로 여러 모듈의 결합체이다. JVM 때문에 다양한 플랫폼 위에서 사용할 수 있다. JVM의 대표적인 역할과 기능으로는 클래스 로딩, GC 등 메모리 관리, 스레드 관리 그리고 예외 처리가 있다.

![image](https://github.com/GDSC-Hongik/2023-2-OC-Java-Study/assets/116694226/61e38092-1257-4fd3-b84c-b1794ea26471)

#### Class Loaders
클래스 로더는 런타임에 자바 클래스/인터페이스의 바이트코드를 동적으로 메모리에 로딩하여 한 번에 모든 클래스가 메모리에 로드되지 않고 필요할 때마다 로드한다. 로딩 작업은 크게 다음 3가지로 분리된다.
- Loading: JVM이 필요한 클래스 파일 로드
- Linking: 로드된 클래스의 verify, prepare, resolve 작업 수행
- Initializing: 클래스/정적 변수 등 초기화

#### JVM Run-Time Data Areas
앱 실행을 위해 사용되는 JVM 메모리 영역이다. 각 영역에 대해서 알아보자.
- The pc Register: 스레드 별로 생성되며 실행 중인 명령을 저장하는 영역
- Java Virtual Machine Stacks: 스레드 별로 생성되며 메서드 실행 관련 정보를 저장하는 영역
- Heap: 스레드 별로 생성되며 모든 객체 인스턴스/배열에 대한 메모리가 할당되는 영역
- Method Area: JVM 실행 시 생성되며 클래스의 구조나 정보를 저장하는 영역
- Native Method Stacks: 스레드 별로 생성되며 네이티브 코드 실행에 관련 정보를 저장하는 영역

#### Excution Engine
JVM 메모리 영역에 있는 바이트코드를 읽어 네이티브 코드로 변환하고 실행하는 역할을 한다.
- Interpreter: 메모리에 로드된 바이트코드를 한 줄씩 해석/실행
- JIT(Just-In-Time) Compiler: 자주 호출되는 메서드의 바이트코드를 네이티브 코드로 컴파일
- GC(Garbage Collector): 메모리에서 사용하지 않는 개체를 식별해 삭제하는 프로세스로써 데몬 스레드로 동작

#### JNI(Java Native Interface)
JNI는 네이티브 라이브러리 사용을 위한 인터페이스이자 동시에 해당 역할을 수행하는 일종의 프레임워크이다. 

#### Native Method Libraries
네이티브 언어/어셈블리와 같은 언어로 작성된 네이티브 메서드를 포함한 라이브러리이고, JVM에서 호출 할 때 JNI를 통해서 로딩된다.

## 컴파일러와 인터프리터
### 컴파일러
프로그래밍 언어로 작성된 코드를 타겟 언어로 변환하는 프로그램이다. 주로 High-Level 언어를 Low-Level 언어로 변환해준다.

### 인터프리터
읽은 코드 및 해당 명령을 직접 분석/실행하는 프로그램이다. 인터프리터의 전략에 대해서 알아보자.
- 코드 구문을 분석, 동작을 직접 수행
- 코드를 object code로 변환, 즉시 실행
- 컴파일러에 의해 생성된 바이트코드를 명시적으로 실행

이렇게 컴파일러 방식과 인터프리터 방식에 대해서 알아보았는데, 자바는 무슨 방식을 사용할까? 자바는 두 가지 방식을 혼합하여 사용하는 `하이브리드 모델`이다. 즉, javac로 소스 코드를 바이트코드로 변환하고, 변환된 바이트코드를 JVM 인터프리터가 분석, 실행한다.

# 클래스 로더와 클래스 로딩
## Class Loaders
런타임에 자바 바이트코드를 JVM 메모리로 동적 로딩을 한다. 먼저, Loading(Creating) 과정을 거쳐 Linking에서 verification, preparation, resolution을 진행하고 Initialization을 한다. 또한, 클래스 로더는 필요한 클래스/리소스만 로딩한다. 

## Class Loaders의 종류
### Bootstrap Class Loader
JVM 시작 시 가장 먼저 실행되는 클래서 로더이다. 그렇기 때문에 자바 클래스를 로드할 수 있는 최소한의 자바 클래스만 로드한다. JDK 9 버전부터 jre/lib/rt.jar가 없어지고 /lib 내에 모듈화가 되었다.

### Platform Class Loader
플랫폼 클래스 로더는 JDK 8 버전의 확장 클래스 로더(Extension Class Loader)가 변경된 것으로 Java SE platform의 모든 API와 클래스를 로딩한다.

### System Class Loader
Java 앱 레벨의 클래스, 클래스 패스 혹은 모듈패스에 있는 클래스를 로딩한다. 쉽게 말해서 .class 파일을 로드한다.

## Class Loaders 원칙
- 위임(Delegation Model): 클래스/리소스 등을 자신이 찾기 전에 먼저 상위 클래스 로더에게 위임
- 유일성(Unique Classes): 상위 클래스 로더가 로딩한 클래스를 하위 클래스 로더가 다시 로딩하는 것을 방지
- 가시성(Visibility): 하위 클래스 로더는 상위 클래스 로더가 로딩한 클래스를 볼 수 있지만 그 반대는 불가능

## 좋은 클래스 로더의 속성
- 클래스 명이 같다면 클래스 로더는 항상 같은 객체를 반환
- 하위 클래스 로더가 상위 클래스로더에게 특정 클래스 로딩을 위임한 경우 두 클래스 로더는 해당 클래스에 대해 동일한 객체를 반환해야 함 (관련된 슈퍼클래스, 필드 타입, 생성자 파라미터, 메서드 반환 타입 등 포함)
- 사용자 정의 클래스 로더가 클래스 바이너리를 미리 가져올 때(Prefetching) 로딩 에러가 발생할 가능성이 있더라도 미리 가져올 때가 아닌 적시에 발생해야 하며 이런 경우 실제 사용 여부 판단이 선행되어야 함

>Prefetching 참고 <br>
다음과 같은 경우 Prefetching은 JVM 구현 방식에 따라 가능하다. 사용 빈도가 높다고 예상되거나 복잡한 종속성이 있다고 판단되는 경우, 해당 클래스와 관련된 클래스 그룹을 같이 로딩하는 경우 (그룹 로딩)

## Loading
특정 이름(FQCN)을 가진 클래스(인터페이스 등)의 바이트코드를 찾아 클래스를 만드는 프로세스이다. 여기서 `FQCN`이란, Full Qualified Class Name의 약자로 클래스가 속한 패키지명을 모두 포함한 이름을 말한다.

```java
// 일반적인 사용법
String s = new String();

// FQCN
java.lang.String s = new java.lang.String();
```

<br>

![image](https://github.com/GDSC-Hongik/2023-2-OC-Java-Study/assets/116694226/2fa49722-786b-4692-aa8e-a993e71dc7d4)

FQCN을 통해 클래스 로딩 시 `ClassNotFoundException`를 조심해야 한다. `ClassNotFoundException`는 FQCN을 통해 클래스 로딩 시 클래스 패스에서 해당 클래스를 찾을 수 없는 경우와 일반적으로 클래스명 등을 통해 리플렉션할 때 발생한다.

또한, `NoClassDefFoundError`는 new 키워드 또는 팩터리 메서드 등을 통한 객체 로드할 때와 일반적으로 static 블록 실행이나 static 변수 초기화 시 예외가 발생한 상황에서 발생한다.

위 문제를 막기 위해서 다음과 같은 주의점을 신경써야 한다.
- 해당 파일의 존재 유무
- 올바른 클래스 패스 설정 여부
- 해당 클래스를 로딩하는 클래스 로더

## Linking
로딩된 클래스를 클래스(인터페이스 등)을 실행하기 위해서 결합(연결)하는 프로세스로 검증, 정적 필드 준비, 심볼릭 레퍼런스 처리 단계가 있다.
각 단계가 어떻게 진행되는지 알아보자.
- 로딩된 바이트코드의 유효성을 검증
- 선언된 static 필드를 초기화, 필요한 메모리를 할당
- 심볼릭 레퍼런스를 실제 참조, 프로세스 등으로 변환

심볼릭 레퍼런스의 검증은 링킹보다 나중에 처리될 수 있으며, 링킹은 새로운 자료구조의 할당을 포함하기 때문에 `OutOfMemoryError`가 발생할 수 있다.

링킹의 활성화 조건에 대해서 알아보자.
- 클래스/인터테이스는 링킹되기 전에 완전히 로딩되어야 함
- 클래스/인터페이스는 초기화되기 전에 완전히 검증되어야 함
- 링킹 중 감지된 오류는 관련 클래스/인터페이스의 링킹이 직간접적으로 필요한 지점에서 발생해야 함 
- 심볼릭 레퍼런스는 실제 참조될 때까지 확인되지 않음 (일종의 Lazy Loading)
    - 동적으로 계산되는 상수의 심볼릭 레퍼런스도 부트스트랩 메서드가 호출할 때까지 확인되지 않음

### Verification
Verification 단계는 Binary Representation(Java Bytecode)의 유효성을 검사하는 프로세스이다. 클래스/인터페이스 바이트코드가 유효하지 않은 경우 이 시점에서 VerifyError 에러가 발생해야 한다. 또한, 검증 중에 LinkageError 에러가 발생하면 이후 검증 시에는 항상 동일한 에러로 실패해야 한다.

### Preparation
Preparation 단계는 클래스/인터페이스의 스태틱 필드를 생성, 필요한 메모리를 할당하며 기본값으로 초기화하는 프로세스이다. 

> Run-Time Constant Pool
>- 클래스/인터페이스가 로딩될 때 메서드 영역에 할당되는 자료구조
>- 일반 상수 풀의 데이터를 기반으로 생성되며 스태틱 상수와 심볼릭 레퍼런스 등을 포함
> - 일반 프로그래밍 언어의 심볼 테이블과 유사하지만 그보다 더 넓은 범위에 데이터를 포함
> - Method Area 영역에서 허용 가능한 메모리를 초과하면 OutOfMemoryError 발생

### Resolution
Resolution 단계는 심볼릭 레퍼런스가 구체적인 값을 가리키도록 동적으로 결정하는 프로세스이다. 이 단계에서는 심볼릭 레퍼런스에 대한 동적 계산이 수행된다.

## Initialization
Initialization 단계는 클래스/인터페이스의 초기화 메서드 등을 실행하며 초기화하고 스페셜 메서드 중 Class Initialization Methods와 정적 필드에 대한 초기화를 한다. 그렇다면 초기화 조건에 대해서 알아보자.
- 인스턴스 생성
- 스태틱 메서드가 호출되거나 참조
- 상수가 아닌 스태틱 필드 사용 시
- 리플렉션을 통한 메서드 호출
- 클래스일 때 서브 클래스의 초기화
- 추상 메서드와 스태틱 메서드를 선언하지 않은 인터페이스일 때 서브 클래스의 초기화
- JVM 로딩 시 초기화되는 클래스/인터페이스로 지정

이 단계는 멀티스레드 환경이기 때문에 초기화 시 `동기화`에 신경써야 한다. 서로 다른 스레드에서 같은 클래스/인터페이스를 동시에 초기화를 시도하는 상황 혹은 초기화 작업으로 재귀적인 초기화가 발생하는 상황을 예로 들 수 있다.

# Java 바이트코드와 코드 캐시
## Java 바이트코드
Java 바이트코드는 Java 컴파일러가 소스 코드를 통해 생성한 JVM이 인식할 수 있는 명령어 집합을 말한다.

## Java 코드 캐시
- JVM이 자바 바이트코드를 컴파일한 네이티브 코드를 저장하는 메모리 영역
- JIT 컴파일러가 코드 캐시 영역을 가장 많이 사용
- 고정된 크기로 확장 불가하며 가득차면 JIT 컴파일러가 꺼져 추가 코드를 컴파일하지 않음

### Java 코드 캐시의 세그먼트
- non-profiled
- profiled-code
- non-method

# 바이트코드를 컴파일하는 AOT, JIT 컴파일러
## AOT 컴파일러
자바 바이트코드를 앱 실행 전 모두 한 번에 컴파일 해두는 방식을 말한다. JDK 17에서 제거되었다고 한다.

## JIT(Just-In-Time) 컴파일러
Hot Method를 추적하여 컴파일한다. JIT 컴파일러는 C1과 C2 컴파일러 모드로 구성된다. 이 두 모드에 대해서 알아보자.

### C1(Client Compiler)
- 런타임에 바이트코드를 기계어로 컴파일
- 빠른 시작과 견고한 최적화가 필요한 앱에서 사용

## C2(Serer Compiler)
- 변환된 기계어를 분석하여 C1보다 오래 걸리지만 더욱 최적화된 네이티브 코드로 컴파일
- 오랫동안 실행을 하는 서버 앱 용도